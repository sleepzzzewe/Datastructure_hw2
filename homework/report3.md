# 作業三 — 雙緩衝 I/O 策略（5 區塊外部排序）

> **學號／組別：** 41243220 41243236  
> **語言：** C++17  
> **程式檔案：** `src/AllPrograms.cpp`（Section 3 `double_buffer_demo.cpp`）

---

## 一、解題說明
* 記憶體僅 5 區塊，需排序 200 000 筆資料，每區塊 2000 筆。  
* 利用 **雙緩衝 (A/B) + 3 個排序緩衝 (S1~S3)**，讓 I/O 與 CPU 同步重疊。

---

## 二、程式實作
> 詳見 `double_buffer_demo.cpp`；核心迴圈：

```cpp
for(int i=0;i<blocks;++i){
    if(i & 1){ thread t(io,'B',i+1); cpu('A',i); t.join(); }
    else      { thread t(io,'A',i+1); cpu('B',i); t.join(); }
}
```
* `io()` 模擬 20 ms 磁碟 I/O；`cpu()` 模擬 10 ms 排序。  
* 交替呼叫達成 Double Buffering。

---

## 三、效能分析
| 參數 | 數值 |
|------|------|
| 區塊 I/O 時間 `t` | 20 ms |
| 區塊容量 `B` | 2000 records |
| 區塊數 | 100 |

\[
 r_{in}=\frac{B}{t}=\frac{2000}{0.02}=\mathbf{100\,000\ records/s}
\]

> CPU 排序 < 20 ms ⇒ 完全重疊，輸入率受磁碟上限支配。

---

## 四、測試與驗證
* 執行程式輸出：I/O 與 CPU 訊息交錯，最後印出 `Max input rate ≈ 100 000 records/s`。  
* 手動將排序延遲調為 25 ms，可觀察 I/O pipeline 被迫等待，驗證瓶頸分析。

---

## 五、申論及開發報告
* **優點**：簡單即達 2× 算力利用率，比單緩衝理論快一倍。  
* **缺點**：只要 CPU > I/O 時間即退化；若記憶體再少，可能需要多趟歸併。  
* **改進**：可引入 *雙輸入＋雙輸出* 以減少寫入等待；或使用異步 I/O 提升實務效率。

---

## 六、結論
體驗了 I/O 與 CPU 重疊 的效能增益；對系統瓶頸有更直觀感受。
學到在記憶體受限時，可透過管線化思想提升整體吞吐。
瞭解外部排序實際需考慮區塊大小、緩衝數量與排序演算法平衡。




